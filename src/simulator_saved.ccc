#include "simulator.h"


int main(){
	char* path;
	char* usage;
	int cachesize, asso, cache_lines, y, z, addr, index;
	int hit = 0;
	int miss = 0;
	FILE *fd;
	int nRet;
	size_t *t = malloc(0);
	char **gptr = malloc(sizeof(char*));
	*gptr = NULL;

	/* Pfad einlesen */
	path = read_path("Bitte Geben Sie einen Pfad ein\nEingabe: ");
	
	/* Cachegröße einlesen */
	cachesize = read_number("Bitte Geben Sie die Cachegroesse an\nEingabe: ");

	/* Assoziativitaet einlesen */
	asso = read_number("Bitte Geben Sie die Assoziativitaet an\n\t1 - direct mapped\n\t2 - 2-Wege-Assoziativ\n\t4 - 4-Wege-Assoziativ\nEingabe: ");
	
	/* Nutzung einlesen */
	usage = read_path("Bitte Geben Sie die Nutzung an\n\tD - Daten-Cache\n\tI - Instruction-Cache\n\tU - Unified(beides)\nEingabe: ");
	
	/* Nutzungselektor bestimmen */
	if (usage[0] == 'U'){
		y = 0;
		z = 2;
	}
	if (usage[0] == 'I'){
		y = 2;
		z = 2;
	}
	if (usage[0] == 'D'){
		y = 0;
		z = 1;
	}
	//printf("%d -- %d\n", y, z);
	/* Arrayzeilen bestimmen und Array anlegen */
	cache_lines = cachesize / WORDLENGTH;
	cacheline* cache[cache_lines][asso];
	
	
	/* ########## Speicher klarmachen ########## */
	for (int hh = 0;hh<asso;hh++) {
		for (int gg = 0; gg <cache_lines; gg++ ) {
			//printf("%p", cache[gg][0]);
			cache[gg][hh] = NULL;
		}
		for (int gg = 0; gg <cache_lines; gg++ ) {
			//printf("%p", cache[gg][hh]);
		}
	}
	/* ########## Speicher klarmachen ########## */
	
	
	if ( (fd = fopen(path,"r")) == NULL) {
		fprintf(stderr, "\nKonnte Datei %s nicht öffnen!", path);
		exit(EXIT_FAILURE);
	}
	
	switch (asso) {
		case 1:
			while( (nRet=getline(gptr, t, fd)) > 0){
				/* prüfen ob die Zeile gelesen werden muss */
				if ((atoi(gptr[0]) >= y) & (atoi(gptr[0]) <= z)) {
					/* Zahl in Dezimal umrechnen und Index bestimmen */
					addr = strtol(gptr[0]+2, NULL, 16);
					index = addr % cache_lines;
					/* Cache prüfen und auslesen oder schreiben */
					printf("Index: %d\n", index);
					int tmp = hit;
					int tmp2 = miss;
					for (int i = 0; i<asso; i++) { 
						/* Entweder wir finden unseren Eintrag oder wir finden nen leeren */
						if (cache[index][i] != NULL) {
							/* Was gefunden */ 
							if (cache[index][i]->tag == addr) {
								/* Hit! */
								hit++;
								age_setter(cache[index], i, asso);
								break;
							}
						} else {
							/* Leerer Eintrag gefunden, ergo is alles danach egal ;) */
							miss++;
							cacheline* new = malloc(sizeof(cacheline));
							new->tag = addr;
							new->age = 0;
							cache[index][i] = new;
							// irgendwas mim Alter machen
							age_setter(cache[index], i, asso);
							break;
						}
					}
					/* Prüfen ob was vorher gefunden wurde. Wenn nicht is das Array voll und unser Eintrag fehlt (noch) */
					if ((tmp == hit) & (tmp2 == miss)) {
						//printf("Zeile: tag[0]: %p | tag[1]: %p\n", cache[index][0], cache[index][1]);
						//printf("tag: tag[0]: %d | tag[1]: %d\n", cache[index][0]->tag, cache[index][1]->tag);
						//printf("age: tag[0]: %d | tag[1]: %d\n", cache[index][0]->age, cache[index][1]->age);
						/* Größten Index suchen */
						int last = age_getter(cache[index], asso);
						//printf("last: \t%d\n", last);
						miss++;
						/* Eintrag reinpacken an älteste Stelle */
						cacheline* new = malloc(sizeof(cacheline));
						new->tag = addr;
						new->age = 0;
						cache[index][last] = new;
						// irgendwas mim Alter machen
						//printf("muhhhhhhhhhhhhh\n");
						age_setter(cache[index], last, asso);
					}
					
				}
				//fputs(*gptr,stdout);
			}
#if (0)			
			while( (nRet=getline(gptr, t, fd)) > 0){
				
				/* prüfen ob die Zeile gelesen werden muss */
				if ((atoi(gptr[0]) >= y) & (atoi(gptr[0]) <= z)) {
					/* Zahl in Dezimal umrechnen und Index bestimmen */
					addr = strtol(gptr[0]+2, NULL, 16);
					index = addr % cache_lines;
					//printf("%s\n", *gptr);
					//printf("%d", index);
					/* Cache prüfen und auslesen oder schreiben */
					if (cache[index][0] == NULL) {
						/* Cache war leer! */
						//printf("cache leer\n");
						miss++;
						cacheline* new = malloc(sizeof(cacheline));
						new->tag = addr;
						cache[index][0] = new;
					} else {
						/* Cache war nicht leer */
						//printf("cache nicht leer\n");
						if (cache[index][0]->tag == addr) {
							//printf("hit \n");
							/* Hit! */
							hit++;
						} else {
							/* Miss! */
							//printf("miss\n");
							miss++;
							cacheline* new = malloc(sizeof(cacheline));
							new->tag = addr;
							cache[index][0] = new;
						}
					}
					
					/* Zeile wird nicht beachtet */	
				}
				//fputs(*gptr,stdout);
			}
#endif
			break;
		case 2:
			while( (nRet=getline(gptr, t, fd)) > 0){
				/* prüfen ob die Zeile gelesen werden muss */
				if ((atoi(gptr[0]) >= y) & (atoi(gptr[0]) <= z)) {
					/* Zahl in Dezimal umrechnen und Index bestimmen */
					addr = strtol(gptr[0]+2, NULL, 16);
					index = addr % cache_lines;
					/* Cache prüfen und auslesen oder schreiben */
					printf("Index: %d\n", index);
					int tmp = hit;
					int tmp2 = miss;
					for (int i = 0; i<asso; i++) { 
						/* Entweder wir finden unseren Eintrag oder wir finden nen leeren */
						if (cache[index][i] != NULL) {
							/* Was gefunden */ 
							if (cache[index][i]->tag == addr) {
								/* Hit! */
								hit++;
								age_setter(cache[index], i, asso);
								break;
							}
						} else {
							/* Leerer Eintrag gefunden, ergo is alles danach egal ;) */
							miss++;
							cacheline* new = malloc(sizeof(cacheline));
							new->tag = addr;
							new->age = 0;
							cache[index][i] = new;
							// irgendwas mim Alter machen
							age_setter(cache[index], i, asso);
							break;
						}
					}
					/* Prüfen ob was vorher gefunden wurde. Wenn nicht is das Array voll und unser Eintrag fehlt (noch) */
					if ((tmp == hit) & (tmp2 == miss)) {
						//printf("Zeile: tag[0]: %p | tag[1]: %p\n", cache[index][0], cache[index][1]);
						//printf("tag: tag[0]: %d | tag[1]: %d\n", cache[index][0]->tag, cache[index][1]->tag);
						//printf("age: tag[0]: %d | tag[1]: %d\n", cache[index][0]->age, cache[index][1]->age);
						/* Größten Index suchen */
						int last = age_getter(cache[index], asso);
						//printf("last: \t%d\n", last);
						miss++;
						/* Eintrag reinpacken an älteste Stelle */
						cacheline* new = malloc(sizeof(cacheline));
						new->tag = addr;
						new->age = 0;
						cache[index][last] = new;
						// irgendwas mim Alter machen
						//printf("muhhhhhhhhhhhhh\n");
						age_setter(cache[index], last, asso);
					}
					
				}
				//fputs(*gptr,stdout);
			}
			break;
		case 4: 
			while( (nRet=getline(gptr, t, fd)) > 0){
				/* prüfen ob die Zeile gelesen werden muss */
				if ((atoi(gptr[0]) >= y) & (atoi(gptr[0]) <= z)) {
					/* Zahl in Dezimal umrechnen und Index bestimmen */
					addr = strtol(gptr[0]+2, NULL, 16);
					index = addr % cache_lines;
					/* Cache prüfen und auslesen oder schreiben */
					printf("Index: %d\n", index);
					int tmp = hit;
					int tmp2 = miss;
					for (int i = 0; i<asso; i++) { 
						/* Entweder wir finden unseren Eintrag oder wir finden nen leeren */
						if (cache[index][i] != NULL) {
							/* Was gefunden */ 
							if (cache[index][i]->tag == addr) {
								/* Hit! */
								hit++;
								age_setter(cache[index], i, asso);
								break;
							}
						} else {
							/* Leerer Eintrag gefunden, ergo is alles danach egal ;) */
							miss++;
							cacheline* new = malloc(sizeof(cacheline));
							new->tag = addr;
							new->age = 0;
							cache[index][i] = new;
							// irgendwas mim Alter machen
							age_setter(cache[index], i, asso);
							break;
						}
					}
					/* Prüfen ob was vorher gefunden wurde. Wenn nicht is das Array voll und unser Eintrag fehlt (noch) */
					if ((tmp == hit) & (tmp2 == miss)) {
						//printf("Zeile: tag[0]: %p | tag[1]: %p\n", cache[index][0], cache[index][1]);
						//printf("tag: tag[0]: %d | tag[1]: %d\n", cache[index][0]->tag, cache[index][1]->tag);
						//printf("age: tag[0]: %d | tag[1]: %d\n", cache[index][0]->age, cache[index][1]->age);
						/* Größten Index suchen */
						int last = age_getter(cache[index], asso);
						//printf("last: \t%d\n", last);
						miss++;
						/* Eintrag reinpacken an älteste Stelle */
						cacheline* new = malloc(sizeof(cacheline));
						new->tag = addr;
						new->age = 0;
						cache[index][last] = new;
						// irgendwas mim Alter machen
						//printf("muhhhhhhhhhhhhh\n");
						age_setter(cache[index], last, asso);
					}
					
				}
				//fputs(*gptr,stdout);
			}
			break;
		default:
			printf("falsche Eingabe?");
			exit(EXIT_FAILURE);
			
	}
	
	printf("Baem, fertig: \n\tHit: %i\n\tMiss: %i\n\tHitrate: %f\n\tMissrate: %f\n\n", hit, miss, (float)hit/((float)miss+(float)hit), (float)miss/((float)miss+(float)hit));
	

}

/* to be done*/
int age_getter(cacheline** cline, int asso){
	int mx = cline[0]->age;
	int pos = 0;
	for (int j = 1; j<asso; j++) { 
		if (cline[j]->age > mx) {
			pos = j;
			mx = cline[j]->age;
		}
	}
	return pos;
}



/* Funktion zum setzen des Alters in einer Cache-line. Rückgabewert gibts nicht */
void age_setter(cacheline** cline, int i, int asso){
	/* Einträge zahlen */
	int max = 0;
	for (int j = 0; j<asso; j++) { 
		if (cline[j] != NULL) {
			max++;
		}
	}
	for (int j = 0; j<max; j++) { 
		if (max != i) {
			cline[j]->age++;
		}
	}
}

/* Funktion zum Abfragen eines Datepfades. Rückgabewert ist der Pfad */
char* read_path(char* question){
	char* erg = malloc(100);
	if (erg == NULL){
		exit(EXIT_FAILURE);
	}
	char text[100];
	int number = 1;
	/* Die Schleife für die Eingabe. Sie wird erst verlassen bei sinnvoller Eingabe */
	while (number) {
		/* Frage stellen  */
		fputs(question, stdout);
		/* Buffer leeren */
		fflush(stdout);
		/* Einlesen */
		if ( fgets(text, sizeof text, stdin) )
		{
			/* Einbabe in eine Zahl umwandeln */
			if ( sscanf(text, "%s", erg) == 1 )
			{
				return erg;
			}else{
				number = -1;
			}
		}else{
			number = -1;
		}
	}
	return erg;
}


/* Methode zum Abfragen einer Zahl. Rückgabewert ist die Zahl */
int read_number(char* question){
	/* char array für die Eingabe. Das Array ist größer 1 um etwas mehr komfort bei der Eingabe zu ermöglichen. */
	char text[20];
	int number = 1;
	/* Die Schleife für die Eingabe. Sie wird erst verlassen bei sinnvoller Eingabe */
	while (number) {
		/* Frage stellen  */
		fputs(question, stdout);
		/* Buffer leeren */
		fflush(stdout);
		/* Einlesen */
		if ( fgets(text, sizeof text, stdin) )
		{
			/* Einbabe in eine Zahl umwandeln */
			if ( sscanf(text, "%d", &number) == 1 )
			{
				return number;
			}else{
				number = -1;
			}
		}else{
			number = -1;
		}
	}
	return number;
}